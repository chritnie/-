- При запуске клиент и сервер генерируют каждый свою пару ключей.<br/> 
- При подключении клиент посылает серверу свой открытый ключ.<br/>
- В ответ сервер посылает клиенту открытый ключ сервера.<br/>
- Клиент посылает сообщение серверу, шифруя его своим закрытым ключом и открытым ключом сервера.<br/>
- Сервер принимает сообщение, расшифровывает его сначала своим закрытым ключом, а потом - открытым ключом клиента.<br/>
- Обратное сообщение посылается аналогично.<br/>
- Для шифровки - расшифровки используем функции симметричного шифрования из предыдущей работы по симметричному шифрованию по Unix.  
![Рисунок1](https://user-images.githubusercontent.com/90050887/146964921-6a85c3c6-b271-4ee5-8604-638d1eed47e2.png)

Далее в функции get_keys() читаем уже существующие ключи, если их нет - создаются новые.
1.	Модифицируйте код клиента и сервера так, чтобы приватный и публичный ключ хранились в текстовых файлах на диске и, таким образом, переиспользовались между запусками. 
Реализовано в коде, можно убедиться что между запусками ключи в файлах не меняются.<br/><br/>
- Csv файл с ключами клиента:

![Рисунок2](https://user-images.githubusercontent.com/90050887/146965466-bc6ff48e-5fab-45b1-81fc-5c0d8e83f9a1.png)

- Csv файл с ключами сервера:

![Рисунок3](https://user-images.githubusercontent.com/90050887/146965468-24569f72-47c4-4a56-bf0c-e36a0ce76b3e.png)

Сервер хранит ключи для каждого из клиентов (по IP).<br/>
2.	Проведите рефакторинг кода клиента и сервера так, чтобы все, относящееся к генерации ключей, установлению режима шифрования, шифрованию исходящих и дешифрованию входящих сообщений было отделено от основного алгоритма обмена сообщениями.<br/> 
Можно увидеть в коде:

![Рисунок4](https://user-images.githubusercontent.com/90050887/146965449-2e733828-fff0-49d7-8664-af775dcc662b.png)
![Рисунок5](https://user-images.githubusercontent.com/90050887/146965453-9a9b1286-3934-4178-a78e-4f5e9e118d6a.png)
![Рисунок6](https://user-images.githubusercontent.com/90050887/146965456-b5269fda-fb5c-4573-80ae-72167d70485c.png)
![Рисунок7](https://user-images.githubusercontent.com/90050887/146965458-e785672a-f259-4cd2-92c7-e017d55d8489.png)
    
3.	Реализуйте на сервере проверку входящих сертификатов. На сервере должен храниться список разрешенных ключей. Когда клиент посылает на сервер свой публичный ключ, сервер ищет его среди разрешенных и, если такого не находит, разрывает соединение. Проверьте правильность работы не нескольких разных клиентах. Важно! данный пункт предполагает, что ключи уже существуют, поэтому в репозитории приложены файлы с уже созданными ключами.<br/><br/>
- Разрешенные открытые ключи клиентов хранятся в файле allowed.csv

![Рисунок8](https://user-images.githubusercontent.com/90050887/146965459-59cbbb3c-5409-4e7b-8de0-2c5222e5674d.png)
 
4.	Модифицируйте код клиента и сервера таким образом, чтобы установление режима шифрования происходило при подключении на один порт, а основное общение - на другом порту. Номер порта можно передавать как первое зашифрованное сообщение. Также можно увидеть в коде, и сервер и клиент выводят сообщение о подключении к конкретному порту. Изначально сервер подключился на порте 10101<br/>
- После подключения клиента они переключились на новый (случайный) порт и продолжают общение на нем

![Рисунок9](https://user-images.githubusercontent.com/90050887/146965462-7a0934c4-611c-4efa-979b-5de37c422978.png)
![Рисунок10](https://user-images.githubusercontent.com/90050887/146965464-bfcf842b-261b-4dcb-860a-d257c37f07a4.png)
  
5.	Модифицируйте код FTP-сервера таким образом, чтобы он поддерживал шифрование.
